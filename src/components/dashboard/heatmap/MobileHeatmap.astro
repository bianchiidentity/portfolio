---
// モバイル用ヒートマップ（元の Heatmap をベースに分割し、可視週数を動的にスライス）
const { exerciseData, bookData, outputData } = Astro.props;
---

<div
  class="bg-white/95 rounded-xl p-4 shadow-lg backdrop-blur-sm border border-white/20 transition-all duration-300 hover:-translate-y-1 hover:shadow-xl overflow-hidden w-full min-w-0"
>
  <div class="flex justify-between items-center mb-4">
    <span class="text-lg font-bold text-gray-800" id="mobile-activityTitle"
      >最近の活動</span
    >
    <div class="flex items-center gap-2 text-sm text-gray-600">
      <span>少ない</span>
      <div class="flex gap-1">
        <div class="w-3 h-3 bg-gray-200 rounded-sm"></div>
        <div class="w-3 h-3 bg-green-300 rounded-sm"></div>
        <div class="w-3 h-3 bg-green-500 rounded-sm"></div>
        <div class="w-3 h-3 bg-green-600 rounded-sm"></div>
        <div class="w-3 h-3 bg-green-800 rounded-sm"></div>
      </div>
      <span>多い</span>
    </div>
  </div>
  <div class="w-full">
    <div
      class="relative h-6 mb-2 overflow-hidden w-full flex justify-start items-center"
      id="mobile-contributionMonths"
    >
    </div>
    <div class="flex items-start">
      <div
        id="mobile-weekdayLabels"
        class="flex flex-col gap-[1px] mr-2 select-none text-xs text-gray-500"
        aria-hidden="true"
      >
      </div>
      <div
        class="flex-1 flex flex-row gap-[3px] overflow-hidden min-h-[140px] p-0 bg-transparent relative items-start w-full flex-nowrap min-w-0 justify-end"
        id="mobile-contributionGrid"
      >
      </div>
    </div>
    <!-- カスタムツールチップ -->
    <div
      id="mobile-customTooltip"
      class="fixed bg-gray-800 text-white text-xs rounded-lg px-3 py-2 pointer-events-none opacity-0 transition-opacity duration-200 z-50 shadow-lg border border-gray-700"
      style="display: none;"
    >
      <div id="mobile-tooltipContent"></div>
    </div>
  </div>
</div>

<script is:inline define:vars={{ exerciseData, bookData, outputData }}>
  // モバイル用のみ実行
  if (window.innerWidth >= 768) {
    // デスクトップ幅の場合は何もしない
  } else {
    const grid = document.getElementById("mobile-contributionGrid");
    const monthsContainer = document.getElementById(
      "mobile-contributionMonths"
    );

    function createContributionGraph() {
      if (!grid) return;
      grid.innerHTML = "";
      if (monthsContainer) monthsContainer.innerHTML = "";

      const today = new Date();
      const endDate = new Date(today);
      // 直近6ヶ月分を対象期間とする（右端=今日）
      const startDate = new Date(today);
      startDate.setMonth(startDate.getMonth() - 6);
      // 週の途中分は後続のパディング処理で揃える

      const allDates = [];
      for (
        let d = new Date(startDate);
        d <= endDate;
        d.setDate(d.getDate() + 1)
      ) {
        allDates.push(new Date(d).toISOString().split("T")[0]);
      }

      const activityData = {};
      (exerciseData || []).forEach((item) => {
        const date = item.date;
        if (!activityData[date])
          activityData[date] = { exercise: 0, reading: 0, output: 0 };
        activityData[date].exercise += 1;
      });
      (bookData || []).forEach((item) => {
        const date = item.date;
        if (!activityData[date])
          activityData[date] = { exercise: 0, reading: 0, output: 0 };
        activityData[date].reading += 1;
      });
      (outputData || []).forEach((item) => {
        const date = item.date;
        if (!activityData[date])
          activityData[date] = { exercise: 0, reading: 0, output: 0 };
        activityData[date].output += 1;
      });

      const weeks = [];
      let currentWeek = [];
      allDates.forEach((dateStr, idx) => {
        const d = new Date(dateStr);
        if (idx === 0) {
          const weekDay = d.getDay();
          for (let i = 0; i < weekDay; i++) currentWeek.push(null);
        }
        currentWeek.push(dateStr);
        if (currentWeek.length === 7) {
          weeks.push(currentWeek);
          currentWeek = [];
        }
      });
      if (currentWeek.length > 0) {
        while (currentWeek.length < 7) currentWeek.push(null);
        weeks.push(currentWeek);
      }

      // 直近6ヶ月すべてを表示対象にし、左のはみ出しは overflow-hidden で隠す
      const totalWeeks = Math.ceil(allDates.length / 7);
      const visibleWeeks = totalWeeks;
      const sliceStart = 0;

      const monthLabels = [];
      // 月曜始まりに合わせて、列インデックスも月曜起点に補正
      allDates.forEach((dateStr, dayIndex) => {
        const d = new Date(dateStr);
        if (d.getDate() === 1) {
          const weekIndexMonStart = Math.floor((dayIndex + 6) / 7);
          const idx = weekIndexMonStart - sliceStart;
          if (idx >= 0 && idx < visibleWeeks) {
            const monthText = d.toLocaleDateString("ja-JP", { month: "short" });
            monthLabels.push({ month: monthText, index: idx });
          }
        }
      });

      weeks.slice(sliceStart).forEach((week, weekIdx) => {
        const weekElement = document.createElement("div");
        weekElement.className =
          "flex flex-col gap-[1px] min-h-4 items-center justify-start flex-shrink-0 box-border";
        // 右端まで詰めるため、最後の列は gap を考慮して位置合わせ
        if (weekIdx === visibleWeeks - 1) weekElement.style.marginRight = "0";

        // 月曜始まりに並べ替え
        const order = [1, 2, 3, 4, 5, 6, 0];
        order.forEach((dayIndex) => {
          const date = week[dayIndex];
          const dayElement = document.createElement("div");
          dayElement.className =
            "w-4 h-4 rounded-sm border border-black/10 bg-gray-200 transition-all duration-200 flex-shrink-0 shadow-sm block min-w-4 min-h-4 box-border hover:scale-120 hover:z-10";
          if (!date) {
            dayElement.className += " bg-transparent border-transparent";
            weekElement.appendChild(dayElement);
            return;
          }

          const activity = activityData[date] || {
            exercise: 0,
            reading: 0,
            output: 0,
          };
          const totalActivity =
            activity.exercise + activity.reading + activity.output;

          if (totalActivity === 0) {
            dayElement.className += " bg-gray-200 border-gray-300";
          } else if (totalActivity === 1) {
            dayElement.className += " bg-green-300 border-green-300";
          } else if (totalActivity === 2) {
            dayElement.className += " bg-green-500 border-green-500";
          } else if (totalActivity === 3) {
            dayElement.className += " bg-green-600 border-green-600";
          } else {
            dayElement.className += " bg-green-800 border-green-800";
          }

          dayElement.dataset.date = date;
          dayElement.dataset.exercise = activity.exercise;
          dayElement.dataset.reading = activity.reading;
          dayElement.dataset.output = activity.output;

          weekElement.appendChild(dayElement);
        });

        grid.appendChild(weekElement);
      });

      if (monthsContainer) {
        monthsContainer.innerHTML = "";
        const monthsRect = monthsContainer.getBoundingClientRect();
        monthsContainer.style.position = "relative";
        monthsContainer.style.width = "100%";
        monthLabels.forEach((label) => {
          const colEl = grid.children[label.index];
          if (!(colEl instanceof HTMLElement)) return;
          const rect = colEl.getBoundingClientRect();
          const center = rect.left - monthsRect.left + rect.width / 2;
          const el = document.createElement("div");
          el.className =
            "text-xs text-gray-500 absolute top-0 whitespace-nowrap px-1 pointer-events-none select-none";
          el.style.position = "absolute";
          el.style.transform = "translateX(-50%)";
          el.style.left = `${center}px`;
          el.textContent = label.month;
          monthsContainer.appendChild(el);
        });
      }
    }

    // 左側の曜日ラベル（「月・水・金」を表示）
    function renderWeekdayLabels() {
      const labelsRoot = document.getElementById("mobile-weekdayLabels");
      if (!labelsRoot) return;
      labelsRoot.innerHTML = "";
      const names = ["月", "", "水", "", "金", "", ""]; // 月水金のみ表示
      names.forEach((name) => {
        const el = document.createElement("div");
        el.className = "w-6 h-4 leading-4 text-right pr-1";
        el.textContent = name;
        labelsRoot.appendChild(el);
      });
    }

    function setupTooltip() {
      const tooltip = document.getElementById("mobile-customTooltip");
      const tooltipContent = document.getElementById("mobile-tooltipContent");
      const gridRoot = document.getElementById("mobile-contributionGrid");
      if (!tooltip || !tooltipContent || !gridRoot) return;

      // body 直下へ移動し、フィルターや overflow の影響を回避
      try {
        if (tooltip.parentElement !== document.body) {
          document.body.appendChild(tooltip);
        }
      } catch (e) {}
      tooltip.style.position = "fixed";
      tooltip.style.zIndex = "9999";
      tooltip.style.pointerEvents = "none";

      let hideTimeoutId = null;
      let activeCell = null;

      function getPoint(event) {
        if (event.touches && event.touches[0]) {
          return { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }
        return { x: event.clientX, y: event.clientY };
      }

      function positionTooltip(event) {
        const { x, y } = getPoint(event);
        tooltip.style.display = "block";
        const rect = tooltip.getBoundingClientRect();
        let left = x;
        let top = y;
        const maxLeft = window.innerWidth - rect.width - 2;
        const maxTop = window.innerHeight - rect.height - 2;
        if (left < 2) left = 2;
        if (left > maxLeft) left = maxLeft;
        if (top < 2) top = 2;
        if (top > maxTop) top = maxTop;
        tooltip.style.left = left + "px";
        tooltip.style.top = top + "px";
        tooltip.style.opacity = "1";
      }

      const overHandler = function (e) {
        const target = e.target;
        if (
          target &&
          target.classList &&
          target.classList.contains("w-4") &&
          target.classList.contains("h-4")
        ) {
          const date = target.dataset.date;
          if (!date) return;
          const exercise = target.dataset.exercise;
          const reading = target.dataset.reading;
          const output = target.dataset.output;

          activeCell = target;
          if (hideTimeoutId) {
            clearTimeout(hideTimeoutId);
            hideTimeoutId = null;
          }
          tooltipContent.innerHTML = `
            <div class="font-semibold mb-1">${date}</div>
            <div>筋トレ: ${exercise}回</div>
            <div>読書: ${reading}回</div>
            <div>アウトプット: ${output}回</div>
          `;
          positionTooltip(e);
        }
      };
      gridRoot.addEventListener("pointerover", overHandler);
      gridRoot.addEventListener("mouseover", overHandler);
      gridRoot.addEventListener("touchstart", overHandler, { passive: true });

      const moveHandler = function (e) {
        if (activeCell) positionTooltip(e);
      };
      gridRoot.addEventListener("pointermove", moveHandler, { passive: true });
      gridRoot.addEventListener("mousemove", moveHandler, { passive: true });
      gridRoot.addEventListener("touchmove", moveHandler, { passive: true });

      gridRoot.addEventListener("pointerout", function (e) {
        const target = e.target;
        if (
          target &&
          target.classList &&
          target.classList.contains("w-4") &&
          target.classList.contains("h-4")
        ) {
          const related = e.relatedTarget;
          if (
            related &&
            gridRoot.contains(related) &&
            related.classList &&
            related.classList.contains("w-4") &&
            related.classList.contains("h-4")
          ) {
            return;
          }
          hideTimeoutId = setTimeout(() => {
            tooltip.style.opacity = "0";
            setTimeout(() => {
              tooltip.style.display = "none";
            }, 150);
          }, 60);
          activeCell = null;
        }
      });
      gridRoot.addEventListener(
        "touchend",
        function () {
          hideTimeoutId = setTimeout(() => {
            tooltip.style.opacity = "0";
            setTimeout(() => {
              tooltip.style.display = "none";
            }, 150);
          }, 60);
          activeCell = null;
        },
        { passive: true }
      );
    }

    function init() {
      if (window.innerWidth >= 768) return; // モバイルのみ
      renderWeekdayLabels();
      createContributionGraph();
      setupTooltip();
    }

    document.addEventListener("DOMContentLoaded", init);
    if (document.readyState !== "loading") {
      init();
    }

    let resizeTimeout;
    window.addEventListener("resize", function () {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(function () {
        if (window.innerWidth < 768) {
          renderWeekdayLabels();
          createContributionGraph();
        }
      }, 250);
    });
    // コンテナの幅変化（レイアウト変更）にも追従
    try {
      const rowContainer = grid?.parentElement;
      if (rowContainer && "ResizeObserver" in window) {
        const ro = new ResizeObserver(() => {
          if (window.innerWidth < 768) {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              renderWeekdayLabels();
              createContributionGraph();
            }, 50);
          }
        });
        ro.observe(rowContainer);
      }
    } catch (_) {}
  }
</script>
